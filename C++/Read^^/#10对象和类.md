## 过程性编程和面向对象编程
- 采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑如何表示这些数据
- 采用OOP时，首先从用户的角度考虑对象——描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。最后使用新的设计方案创建出程序

## 抽象和类
将问题的本质特征抽象出来，并根据特征来描述解决方案。
在C++中，用户定义类型指的是实现抽象接口的类设计
### 什么是类型
讨厌鬼：胖、黑边眼镜……
char：占用1个字节的内存
double：占用8个字节的内存
将变量声明为int或float指针时，不仅仅是分配内存，还规定了可对变量执行的操作
- 指定基本类型完成了3项工作：
1. 决定数据对象需要的内存数量
2. 决定如何解释内存中的位
3. 决定可使用数据对象执行的操作或方法
对于内置类型，其油管操作的信息被内置到编译器中。但在C++中定义用户自定义的类型时，必须自己提供这些信息。
### cpp中的类
一般来说，类规范由两个部分组成:
1. 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口
2. 类方法定义：描述如何实现类成员函数
类声明提供了类的蓝图，而方法定义则提供了细节
? 什么是接口
- 程序接口将用户的意图转换为存储在计算机中的具体信息
- 公共接口：公众是使用类的程序，交互系统由类对象组成，而接口由编写类的人提供的方法组成。接口让程序员能编写与类对象交互的代码，从而让程序能够使用类对象。例如要计算string对象的长度，无需打开对象，只需使用string类所提供的size()方法。
下面是开发一个类的完整步骤：
```C++
#include<iostream>
#include<cstring>

class Stock //类声明
{
private:
    char company[30];
    int shares;
    double share_val;
    double total_val;
    void ser_tot(){total_val = shares*share_val;}
public:
    void acquire(const char*co, int n, double pr );
    void buy(int num, double price);
    void show();
};

Stock sally;
Stock solly;//创建两个Stock对象

```
1. 创建两个Stock对象
2. 要存储的数据以类数据成员的形式出现(如company和shares)
3. 要执行的操作以类函数成员的形式出现，对于描述函数接口而言，函数原型就足够了。
- 该例说明了成员函数是如何建立的。例如，头文件iostream将getline()的原型放在istream类的声明中
- 使用类对象的程序开源直接访问public关键字后的部分，但只能通过公有成员函数来访对象的私有成员。比如说要修改Stock类的shares成员，只能通过Stock的成员函数作出修改。因此公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口
- 防止程序直接访问数据被称为数据隐藏，确保了数据的完整性

- 类的设计尽可能将公有接口与实现细节分开。将实现细节放在一起并将它们与抽象分开被称为封装。
- 数据隐藏是一种封装，将实现的细节隐藏在私有部分中，就像Stock类对set_tot()这样。封装的另一个例子是，将类函数定义和类声明放在不同的文件。

-- OOP是一种编程风格
- 无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分；否则无法从程序中调用这些函数。

- 不必在类声明中使用关键字private，因为这是类对象的默认访问控制。

### 实现类成员函数
为类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义较为相似，都有函数头、函数体、返回类型、参数，由两个特殊的特征：
1. 定义成员函数时，使用作用域解析操作符::来标识函数所属的类
2. 类方法可以访问类的private组件
- 举个例子，update()成员函数的函数头如下：void Stock::update(double price)这表示我们定义的update()函数是Stock类的成员
这意味着：1. update()函数为成员函数2. 在另一个类中可以用同样的名字

- Stock类的其他成员函数不必使用作用域解析操作符就可以使用update方法，这是因为它们属于同一个类
-类名：Stock::update()是函数的限定名(qualified name)
    update()是全名的缩写(unqualified name),只能在类作用域中使用

- 第二个特点是可以访问类的私有成员。编译器将禁止使用非成员函数访问私有数据成员

- 和cout一样，cerr也是一个ostream对象。它们之间的区别在于，操作系统重定向只影响cout，不影响cerr。cerr对象用于错误消息。

### 内联方法
- 定义位于类声明中的函数都将自动称为内联函数，因此Stock::set_tot()是一个内联函数。类声明常将短小的成员函数作为内联函数
- 也可以在类声明之外定义成员函数，使其称为内联函数。只需在类实现部分中定义函数时使用inline限定符即可
```C++
class Stock{
    private:
    ···
    public:
    ···
}

inline void Stock::set_tot() // 在定义时加inline关键字
{
    total_val=shares*share_val;
}
```
内联函数要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用、最简便的方法是：将内联定义放在定义类的头文件中。
- 在类声明中定义方法等同于用原型替换方法定义，然后再类声明的后面将定义改写为内联函数。

## 对象如何使用方法
```C++
Stock kate, joe; // 创建两个Stock对象

kate.show();
joe.show();
// 调用成员函数时，它将使用被用来调用它的对象的数据成员
```
- 在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给2个不同的对象将调用同一个方法，但该方法被用于2个不同的对象.例如kate和joe虽然占据不同的内存块，但kate.show()和joe.show()都调用同一个方法，执行提那个一个代码块，只是将这些代码用于不同的数据

using std::ios_base;
这是一种嵌套名称空间的情形。标识符fixed和showpoint位于名称空间ios_base中，而名称空间ios_base位于名称空间std中

## 类的构造函数和析构函数 