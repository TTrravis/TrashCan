<!--
 * @FileName: Do not edit
 * @Author: TTrravis 1224755884@qq.com
 * @Date: 2022-09-07 10:04:55
 * @LastEditors: TTrravis 1224755884@qq.com
 * @LastEditTime: 2022-09-07 15:39:43
 * @Description: 
 * 
 * Copyright (c) 2022 by TTrravis 1224755884@qq.com, All Rights Reserved. 
-->
```Java
//取数组第一项
与python相同，java取特定位的元素时，直接nums[index]即可

//删除原数组第一项
nums.shift();

//删除原数组最后一项，并返回删除元素的值
//数组为空则返回undefined
nums.pop();

//将数组反序
nums.reverse();// 注意要加StringBuffer才能反序

//将元素加入原数组末尾，并返回新数组的长度
nums.push();

//返回原数组中的一段切片
slice(start,end);

//按指定参数对数组排序
sort(orderfunction);

//@Override注解
用来指定方法重写，只能修饰方法并且只能用于方法重写。它可以强制一个子类必须重写父类方法或者实现接口的方法。用于帮助程序员避免一些低级错误
如果不加@Override注解，即便是方法编辑错误了，编译器也不会由提示，这时Object父类方法没有被重写，将会引起程序出现Bug

//Override重写与Overload重载
* 重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变，即外壳不变，核心重写
* 重载是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

//列表是否包含某元素
arr.contain(obj);//返回布尔值

//获取数组长度
pulic class Main{
    public static void main(String args[]){
        String[][] data = new String[2][5];//创建一个对象
        System.out.println("一维数组长度" + data.length);
        System.out.println("二维数组长度" + data[0].length);
    }
}

//遍历数组中元素
int [] arr={1,2,3...n};
for(int i=0;i<arr.length()))

//java初始化一个列表
int arr[] = new int[]{a1,a2,a3};

//list添加元素方法
list.add(element);//先加的排在前面
list.add(index, element);//在索引处添加元素

//数组排序
Arrays.sort(nums)

// java中最大整数是:[-2^31,2^31-1],一共2^32个整数

//java位运算符
//共7种位运算符，分别是 
//按位与&、按位或|、按位异或^、取反~、左移<<、带符号右移>>、无符号右移>>>
//位运算符对long\int\short \byte\char五种类型数据运算
1. 例如5&6，先把5和6转化为补码，按照"1&0=0,1&1=1,0&0=0,0&1=0"规则运算，结果为4
2. 规则"0|0=0,0|1=1,1|0=1,1|1=1"
3. 找不同，相同为0，不同为1:0^0=0,1^0=1,1^1=0,0^1=1(异或运算满足交换律)
4. 按位取反，即0->1,1->0，写法是~(对一个数取反并不改变其原有的值！)
5. 左移乘2.移动的位数决定要乘几个2
例如：5<<2输出为20
6. 带符号右移：正数则0补位，负数则1补位
* 对于正数，效果类似于有几位就除以几个2，例如15>>3输出1
* 对于负数，分为两种情况
(1)如果该负数为2^N的整数倍，则返回值为该数/(2^N)，例如-16>>3输出-2
(2)如果该负数不满足上述条件，则在除的操作基础上还要减1
7. 无符号右移
0补位。对正数而言，无符号右移与带符号右移无区别；对负数而言，会产生一个正数。
```

## copyOf方法
copyOf(int[] original, int newLength);
其中original为要拷贝的数组对象，newLength为拷贝的新数组对象

## protected关键字详解
被protected修饰的成员对于本包和其子类可见


# 值传递pass-by-value
在调用函数时将实际参数复制一份传递到函数中，这样函数中如果对参数值进行修改，将不会影响到实际参数
# 引用传递pass-by-reference
在调用函数时将实际参数的地址直接传递到函数中，这样函数中如果对参数进行修改，将会影响到实际参数值
## 区别
值传递会创建副本；引用传递不创建副本
所以值传递函数中无法改变原始对象，引用传递函数中可以改变原始对象
## 要点
1. 如果在函数里修改传给函数的值，实际上修改的是实参的副本，实参值本身并没有改变
2. 一个函数在使用参数时，如果使用引用传递方式，编译系统会在调用该函数的地方，直接将实参的内存地址传给形参
2.1 由于函数的参数传递的是把实参的地址拷贝给形参，因此形参和实参对应同一块内存地址，所以形参的修改自然会反映到实参上
2.2 在C++中，指针是一个int类型，所以即使在64位系统中，指针的复制成本也是完全可以接受的
2.3 如果传进的参数是指针类型，则需要先判断指针是否为空，易用性不强
* 一般情况下，在C++中使用“引用传递”会更好
```C++
int FunA(const string strTest) //值传递
{
    // codes
}

int FunB(const string & strTest) //引用传递，这里加了const关键字，为常引用
{
    // codes
}
```