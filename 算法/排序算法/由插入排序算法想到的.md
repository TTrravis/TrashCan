

## 问题背景
给定一个数组，按升序进行排序
## 基本思想
与插入排序相同的是，我们在一开始还是将数组划分为两个区域，即有序区和即将插入的新元素区。第一步还是默认数组第一位数为一个有序区，再依次对其后面的新元素进行遍历，再有序区内的每一个元素比较大小
与插入排序不同的是，对每一个即将插入的新元素，若某有序区内的元素大于该新元素，
* 插入排序采用的操作是将该元素(有序区的某元素)向后挪一个位置，然后继续在有序区中往前遍历，直到发现某元素小于这个新元素的值，此时萝卜坑的位置恰好就是我们要插入新元素的位置。退出循环，在萝卜坑里插入新元素的值即可。
* 而我发现了另一个可行的操作，就是在此时(某有序区内的元素大于该新元素),交换这两个元素的位置。然后继续往前遍历，不停交换位置，由于新元素的索引i值在一个for循环内是一个定值，所以即使新元素的值会发生变化，但它依然在发生交换。直到子for循环结束，排序完成。
## 反思
仔细思考了一下，交换排序算法其实算是一个反向优化qwq
* 首先是时间复杂度，在插入排序中当新元素值比有序区的某数大时即跳出for循环，这么做一方面充分利用了从后往前遍历有序区的特点，另一方面节约了时间，不需要再遍历下去了；而交换排序则需要for循环每一个都遍历到。简单计算一下，虽然他俩时间复杂度都为O(n^2)，但在实际运行过程中，插排应该是略胜一筹(猜的)
* 再是空间复杂度，通常来说，只要算法不涉及到动态分配的空间，以及递归、栈所需的空间，空间复杂度通常为0(1)
# 当然在这一过程中还可以用二分查找实现，显然这种方法更加优化，在这里就不再赘述了。此篇仅为一点新的idea而作的探讨~